{"Link_to_commit": "https://github.com/duckdb/duckdb/commit/242d3f78e4651f5f99f77f33cc05d2b72a986d3d", "n-gram matched": "generated by copilot", "n_lines_longer_change": 235, "n_files_impacted": 15, "longest_chunk": ["#include \"duckdb/parser/tableref/at_clause.hpp\"", "", "namespace duckdb {", "", "AtClause::AtClause(string unit_p, unique_ptr<ParsedExpression> expr_p)", "    : unit(std::move(unit_p)), expr(std::move(expr_p)) {", "}", "", "string AtClause::ToString() const {", "\treturn \"AT (\" + unit + \" => \" + expr->ToString() + \")\";", "}", "", "bool AtClause::Equals(const AtClause &other) const {", "\treturn unit == other.unit && expr->Equals(*other.expr);", "}", "", "unique_ptr<AtClause> AtClause::Copy() const {", "\treturn make_uniq<AtClause>(unit, expr->Copy());", "}", "", "bool AtClause::Equals(optional_ptr<AtClause> lhs, optional_ptr<AtClause> rhs) {", "\tif (lhs.get() == rhs.get()) {", "\t\t// same pointer OR both are null", "\t\treturn true;", "\t}", "\tif (!lhs || !rhs) {", "\t\t// one is NULL other is not - always not equal", "\t\treturn false;", "\t}", "\treturn lhs->Equals(*rhs);", "}", "", "} // namespace duckdb"], "file_path": "src/parser/tableref/at_clause.cpp"}
{"Link_to_commit": "https://github.com/amarantesharlon/duckdb/commit/242d3f78e4651f5f99f77f33cc05d2b72a986d3d", "n-gram matched": "generated by copilot", "n_lines_longer_change": 235, "n_files_impacted": 15, "longest_chunk": ["#include \"duckdb/parser/tableref/at_clause.hpp\"", "", "namespace duckdb {", "", "AtClause::AtClause(string unit_p, unique_ptr<ParsedExpression> expr_p)", "    : unit(std::move(unit_p)), expr(std::move(expr_p)) {", "}", "", "string AtClause::ToString() const {", "\treturn \"AT (\" + unit + \" => \" + expr->ToString() + \")\";", "}", "", "bool AtClause::Equals(const AtClause &other) const {", "\treturn unit == other.unit && expr->Equals(*other.expr);", "}", "", "unique_ptr<AtClause> AtClause::Copy() const {", "\treturn make_uniq<AtClause>(unit, expr->Copy());", "}", "", "bool AtClause::Equals(optional_ptr<AtClause> lhs, optional_ptr<AtClause> rhs) {", "\tif (lhs.get() == rhs.get()) {", "\t\t// same pointer OR both are null", "\t\treturn true;", "\t}", "\tif (!lhs || !rhs) {", "\t\t// one is NULL other is not - always not equal", "\t\treturn false;", "\t}", "\treturn lhs->Equals(*rhs);", "}", "", "} // namespace duckdb"], "file_path": "src/parser/tableref/at_clause.cpp"}
{"Link_to_commit": "https://github.com/0xmicrosoft15/duckdb-rich-sql/commit/ac4ba19da526c4ec2c009b90a25898914b01d71b", "n-gram matched": "generated by copilot", "n_lines_longer_change": 235, "n_files_impacted": 15, "longest_chunk": ["#include \"duckdb/parser/tableref/at_clause.hpp\"", "", "namespace duckdb {", "", "AtClause::AtClause(string unit_p, unique_ptr<ParsedExpression> expr_p)", "    : unit(std::move(unit_p)), expr(std::move(expr_p)) {", "}", "", "string AtClause::ToString() const {", "\treturn \"AT (\" + unit + \" => \" + expr->ToString() + \")\";", "}", "", "bool AtClause::Equals(const AtClause &other) const {", "\treturn unit == other.unit && expr->Equals(*other.expr);", "}", "", "unique_ptr<AtClause> AtClause::Copy() const {", "\treturn make_uniq<AtClause>(unit, expr->Copy());", "}", "", "bool AtClause::Equals(optional_ptr<AtClause> lhs, optional_ptr<AtClause> rhs) {", "\tif (lhs.get() == rhs.get()) {", "\t\t// same pointer OR both are null", "\t\treturn true;", "\t}", "\tif (!lhs || !rhs) {", "\t\t// one is NULL other is not - always not equal", "\t\treturn false;", "\t}", "\treturn lhs->Equals(*rhs);", "}", "", "} // namespace duckdb"], "file_path": "src/parser/tableref/at_clause.cpp"}
{"Link_to_commit": "https://github.com/cespinoza01/AzureSentinel/commit/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://github.com/deepsharan2812/Microsoft-Sentinel/commit/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://github.com/SivaTejaReddy12125/SentinelLab/commit/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://github.com/mikebarlow/mikebarlow.github.io/commit/a10243a018d5384dd741c4070a87ec8ef91ce141", "n-gram matched": "generated by copilot", "n_lines_longer_change": 325, "n_files_impacted": 7, "longest_chunk": ["const defaultTheme = require(\"tailwindcss/defaultTheme\");", "", "module.exports = {", "  content: [\"./**/*.html\"],", "  safelist: [\"active\"],", "  theme: {", "    fontFamily: {", "      header: [\"Raleway\", \"sans-serif\"],", "      body: [\"Open Sans\", \"sans-serif\"],", "    },", "", "    screens: {", "      xs: \"375px\",", "      ...defaultTheme.screens,", "    },", "", "    colors: {", "      transparent: \"transparent\",", "      primary: \"#5540af\",", "      secondary: \"#252426\",", "      white: \"#ffffff\",", "      black: \"#000000\",", "      yellow: \"#f9e71c\",", "      lila: \"#e6e5ec\",", "      \"grey-10\": \"#6c6b6d\",", "      \"grey-20\": \"#7c7c7c\",", "      \"grey-30\": \"#919091\",", "      \"grey-40\": \"#929293\",", "      \"grey-50\": \"#f4f3f8\",", "      \"grey-60\": \"#edebf6\",", "      \"grey-70\": \"#d8d8d8\",", "      \"hero-gradient-from\": \"rgba(85, 64, 174, 0.95)\",", "      \"hero-gradient-to\": \"rgba(65, 47, 144, 0.93)\",", "      \"blog-gradient-from\": \"#8f9098\",", "      \"blog-gradient-to\": \"#222222\",", "    },", "", "    container: {", "      center: true,", "      padding: \"1rem\",", "    },", "", "    shadows: {", "      default: \"0 2px 18px rgba(0, 0, 0, 0.06)\",", "      md: \"0 -3px 36px rgba(0, 0, 0, 0.12)\",", "    },", "", "    extend: {", "      spacing: {", "        13: \"3.25rem\",", "        15: \"3.75rem\",", "        17: \"4.25rem\",", "        18: \"4.5rem\",", "        19: \"4.75rem\",", "        42: \"10.5rem\",", "        76: \"19rem\",", "        84: \"21rem\",", "        88: \"22rem\",", "        92: \"23rem\",", "        100: \"25rem\",", "        104: \"26rem\",", "        108: \"27rem\",", "        112: \"28rem\",", "        116: \"29rem\",", "        120: \"30rem\",", "        124: \"31rem\",", "        128: \"32rem\",", "        132: \"33rem\",", "        136: \"34rem\",", "        140: \"35rem\",", "        144: \"36rem\",", "        148: \"37rem\",", "        152: \"38rem\",", "        156: \"39rem\",", "        160: \"40rem\",", "        164: \"41rem\",", "        168: \"42rem\",", "        172: \"43rem\",", "        176: \"44rem\",", "        180: \"45rem\",", "        184: \"46rem\",", "        188: \"47rem\",", "        190: \"48rem\",", "        194: \"49rem\",", "        200: \"50rem\",", "        204: \"51rem\",", "      },", "      zIndex: {", "        \"-1\": \"-1\",", "        60: \"60\",", "        70: \"70\",", "      },", "      inset: {", "        \"2/5\": \"40%\",", "      },", "    },", "  },", "  plugins: [", "    require(\"@tailwindcss/typography\"),", "    require(\"@tailwindcss/forms\"),", "    require(\"@tailwindcss/aspect-ratio\"),", "  ],", "};"], "file_path": "tailwind.config.js"}
{"Link_to_commit": "https://github.com/almost-matching-exactly/DAME-FLAME-Python-Package/commit/879822ff07ff6ec25101e20d44bf79409b5c702e", "n-gram matched": "generated by copilot", "n_lines_longer_change": 171, "n_files_impacted": 4, "longest_chunk": ["", "def var_ATE(matching_object, mice_iter=0):", "    '''", "    This is an EXPERIMENTAL function that implements the variance found in ", "    Abadie, Drukker, Herr, and Imbens (The Stata Journal, 2004) assuming", "    constant treatment effect and homoscedasticity. Note that the implemented ", "    estimator is NOT asymptotically normal and so in particular, ", "    asymptotically valid confidence intervals or hypothesis tests cannot be ", "    conducted on its basis. In the future, the estimation procedure will be ", "    changed.", "", "    Parameters", "    ----------", "    matching_object : TYPE", "        DESCRIPTION.", "    mice_iter : TYPE, optional", "        DESCRIPTION. The default is 0.", "", "    Returns", "    -------", "    variance: float", "    '''", "    validate_matching_obj(matching_object)", "", "    # Compute the sigma^2 estimate from equation 10 in Abadie et al", "    # units_per_group is in format [[#,#,#,...], [#,#,#,...],..]", "    # Need to double check this, if mice_iter != 0, then possibly need to index", "    units_per_group = matching_object.units_per_group", "    ", "    mmgs_dict = all_MGs(matching_object)", "    # print(mmgs_dict)", "        ", "    # Compute K_dict, which maps i to KM value", "    K_dict = dict.fromkeys(mmgs_dict,0)", "    km_temp = 0", "    treated_col = matching_object.treatment_column_name", "    for i in matching_object.df_units_and_covars_matched.index:        ", "        # iterate through all matched units of indexes with opposite treatment", "        # values. How many of those MMGs am I in, and", "        # if I'm in someone's MMG, what is the size of their MMG?", "", "        is_treatment_val = matching_object.input_data.loc[i, treated_col]", "        ", "        ''' # This works for only the without repeats case!", "        for group in units_per_group:", "            if i in group:", "                # find out how many people in this mmg", "                # have the opposite treatment status to the treatment_val_mmg", "                num_treated = sum(matching_object.input_data.loc[group, 'treated'])", "                if is_treatment_val:", "                    num_opposite = len(group) - num_treated", "                else:", "                    num_opposite = num_treated", "                    ", "                K_dict[i] += num_opposite/(len(group)-num_opposite) # is this right???  # (num_opposite/len(group)) # I think this is right per convo w Vittorio", "        ''' # This works for both! Technically somewhat slower though!", "        for j in matching_object.df_units_and_covars_matched.index:", "            if i in mmgs_dict[j] and matching_object.input_data.loc[j, treated_col] != is_treatment_val:", "                num_treated = sum(matching_object.input_data.loc[mmgs_dict[j], treated_col])", "                if matching_object.input_data.loc[j, treated_col]: # double think -- you have to be opposite of j != opp of i", "                    num_opposite = len(mmgs_dict[j]) - num_treated", "                else:", "                    num_opposite = num_treated", "                # print(\"i\", i, \"j\", j, \"num_opp\", num_opposite)", "                K_dict[i] += 1/num_opposite", "        ", "    # print(K_dict)", "    # Compute ATE per simple estimator in paper -- this should be right", "    ate = 0", "    for i in mmgs_dict:", "        treatment_val = matching_object.input_data.loc[i, treated_col]", "        outcome_val = matching_object.input_data.loc[", "            i, matching_object.outcome_column_name]", "        ate += ((2*treatment_val - 1)*(1 + K_dict[i])*outcome_val)", "    ate = ate/len(mmgs_dict)", "        ", "    # Compute sigma^2. ", "    i_summation = 0", "    for i in mmgs_dict:", "        group_members = mmgs_dict[i] # these are the l values in Jm(i)", "        treatment_val = matching_object.input_data.loc[i, treated_col]", "        outcome_val = matching_object.input_data.loc[", "            i, matching_object.outcome_column_name]", "        opp_group_members = matching_object.input_data.loc[group_members].index[matching_object.input_data.loc[group_members][treated_col] != treatment_val].tolist()", "        # iterate through my group members -- only the ones w opp treatment to me!", "        temp_l_summation = 0", "        for l in opp_group_members:", "            Y_l = matching_object.input_data.loc[", "            l, matching_object.outcome_column_name]", "            if treatment_val:", "                temp_l_summation += ((outcome_val - Y_l - ate)**2)", "            else:", "                temp_l_summation += ((Y_l - outcome_val - ate)**2)         ", "        i_summation += temp_l_summation/len(opp_group_members)", "    sigma_squared = 1/(2*len(mmgs_dict))*i_summation", "    ", "    # Combine the above to compute var_estimator", "    dict_summation = 0", "    for key, value in K_dict.items():", "        dict_summation += (1+value)**2", "    var_estimator = sigma_squared*dict_summation/(len(mmgs_dict)**2)", "    ", "    return var_estimator, ate"], "file_path": "dame_flame/utils/post_processing.py"}
{"Link_to_commit": "https://github.com/utkarsh2102-debian-lts/qt4-x11/commit/2171bcb424bcc3e2c3a0bb2b17a7318ab447db38", "n-gram matched": "generated by copilot", "n_lines_longer_change": 25, "n_files_impacted": 1, "longest_chunk": ["#include <sys/types.h>", "#include <dirent.h>", "#include <errno.h>", "#include <stdio.h>", "", "main() {", "  int return_code;", "  DIR *dir;", "  struct dirent entry;", "  struct dirent *result;", "", "  if ((dir = opendir(\".\")) == NULL)", "    perror(\"opendir() error\");", "  else {", " //   puts(\"contents of .:\");", "    for (return_code = readdir_r(dir, &entry, &result);", "         result != NULL && return_code == 0;", "         return_code = readdir_r(dir, &entry, &result))", "      printf(\"%s\\n\", entry.d_name);", "    if (return_code != 0)", "      perror(\"readdir_r() error\");", "    closedir(dir);", "  }", "}", ""], "file_path": "debian/readdir-hppa-test.c"}
{"Link_to_commit": "https://github.com/pexip/os-glib2.0/commit/ae5b4a0393503c68c2757d2e11c071ad97487af6", "n-gram matched": "generated by copilot", "n_lines_longer_change": 133, "n_files_impacted": 1, "longest_chunk": ["#!/usr/bin/env python3", "#", "# === clang-format-diff.py - ClangFormat Diff Reformatter ---*- python -*-=== #", "#", "# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "# See https://llvm.org/LICENSE.txt for license information.", "# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "#", "# ===---------------------------------------------------------------------=== #", "", "\"\"\"", "This script reads input from a unified diff and reformats all the changed", "lines. This is useful to reformat all the lines touched by a specific patch.", "Example usage for git/svn users:", "", "  git diff -U0 --no-color HEAD^ | clang-format-diff.py -p1 -i", "  svn diff --diff-cmd=diff -x-U0 | clang-format-diff.py -i", "", "\"\"\"", "from __future__ import absolute_import, division, print_function", "", "import argparse", "import difflib", "import re", "import subprocess", "import sys", "", "if sys.version_info.major >= 3:", "    from io import StringIO", "else:", "    from io import BytesIO as StringIO", "", "", "def main():", "    parser = argparse.ArgumentParser(", "        description=__doc__,", "        formatter_class=argparse.RawDescriptionHelpFormatter)", "    parser.add_argument('-i', action='store_true', default=False,", "                        help='apply edits to files instead of displaying a '", "                             'diff')", "    parser.add_argument('-p', metavar='NUM', default=0,", "                        help='strip the smallest prefix containing P slashes')", "    parser.add_argument('-regex', metavar='PATTERN', default=None,", "                        help='custom pattern selecting file paths to reformat '", "                        '(case sensitive, overrides -iregex)')", "    parser.add_argument('-iregex', metavar='PATTERN',", "                        default=r'.*\\.(cpp|cc|c\\+\\+|cxx|c|cl|h|hh|hpp|m|mm|inc'", "                                r'|js|ts|proto|protodevel|java|cs)',", "                        help='custom pattern selecting file paths to reformat '", "                             '(case insensitive, overridden by -regex)')", "    parser.add_argument('-sort-includes', action='store_true', default=False,", "                        help='let clang-format sort include blocks')", "    parser.add_argument('-v', '--verbose', action='store_true',", "                        help='be more verbose, ineffective without -i')", "    parser.add_argument('-style',", "                        help='formatting style to apply (LLVM, Google, '", "                        'Chromium, Mozilla, WebKit)')", "    parser.add_argument('-binary', default='clang-format',", "                        help='location of binary to use for clang-format')", "    args = parser.parse_args()", "", "    # Extract changed lines for each file.", "    filename = None", "    lines_by_file = {}", "    for line in sys.stdin:", "        match = re.search(r'^\\+\\+\\+\\ (.*?/){%s}(\\S*)' % args.p, line)", "        if match:", "            filename = match.group(2)", "        if filename is None:", "            continue", "", "        if args.regex is not None:", "            if not re.match('^%s$' % args.regex, filename):", "                continue", "        else:", "            if not re.match('^%s$' % args.iregex, filename, re.IGNORECASE):", "                continue", "", "        match = re.search(r'^@@.*\\+(\\d+)(,(\\d+))?', line)", "        if match:", "            start_line = int(match.group(1))", "            line_count = 1", "            if match.group(3):", "                line_count = int(match.group(3))", "            if line_count == 0:", "                continue", "            end_line = start_line + line_count - 1", "            lines_by_file.setdefault(filename, []).extend(", "                ['-lines', str(start_line) + ':' + str(end_line)])", "", "    # Reformat files containing changes in place.", "    # We need to count amount of bytes generated in the output of", "    # clang-format-diff. If clang-format-diff doesn't generate any bytes it", "    # means there is nothing to format.", "    format_line_counter = 0", "    for filename, lines in lines_by_file.items():", "        if args.i and args.verbose:", "            print('Formatting {}'.format(filename))", "        command = [args.binary, filename]", "        if args.i:", "            command.append('-i')", "        if args.sort_includes:", "            command.append('-sort-includes')", "        command.extend(lines)", "        if args.style:", "            command.extend(['-style', args.style])", "        p = subprocess.Popen(command,", "                             stdout=subprocess.PIPE,", "                             stderr=None,", "                             stdin=subprocess.PIPE,", "                             universal_newlines=True)", "        stdout, _ = p.communicate()", "        if p.returncode != 0:", "            sys.exit(p.returncode)", "", "        if not args.i:", "            with open(filename) as f:", "                code = f.readlines()", "            formatted_code = StringIO(stdout).readlines()", "            diff = difflib.unified_diff(code, formatted_code,", "                                        filename, filename,", "                                        '(before formatting)',", "                                        '(after formatting)')", "            diff_string = ''.join(diff)", "            if diff_string:", "                format_line_counter += sys.stdout.write(diff_string)", "", "    if format_line_counter > 0:", "        sys.exit(1)", "", "", "if __name__ == '__main__':", "    main()"], "file_path": "clang-format-diff.py"}
{"Link_to_commit": "https://github.com/Azure/Azure-Sentinel/commit/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://github.com/NusantaraROM-Devices/kernel_xiaomi_lmi/commit/4dd00bfb425b7ba23abddb8bd3356cc36b4d5903", "n-gram matched": "generated by copilot", "n_lines_longer_change": 150, "n_files_impacted": 5, "longest_chunk": ["\tstruct kretprobe_instance *ri = NULL;", "\tstruct hlist_head *head, empty_rp;", "\tstruct hlist_node *tmp;", "\tunsigned long flags, orig_ret_address = 0;", "\tunsigned long trampoline_address =", "\t\t(unsigned long)dereference_function_descriptor(kretprobe_trampoline);", "", "\tINIT_HLIST_HEAD(&empty_rp);", "\tkretprobe_hash_lock(current, &head, &flags);", "", "\t/*", "\t * It is possible to have multiple instances associated with a given", "\t * task either because an multiple functions in the call path", "\t * have a return probe installed on them, and/or more than one return", "\t * return probe was registered for a target function.", "\t *", "\t * We can handle this because:", "\t *     - instances are always inserted at the head of the list", "\t *     - when multiple return probes are registered for the same", "\t *       function, the first instance's ret_addr will point to the", "\t *       real return address, and all the rest will point to", "\t *       kretprobe_trampoline", "\t */", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "", "\tregs->cr_iip = orig_ret_address;", "", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\tif (ri->rp && ri->rp->handler)", "\t\t\tri->rp->handler(ri, regs);", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\trecycle_rp_inst(ri, &empty_rp);", "", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "\tkretprobe_assert(ri, orig_ret_address, trampoline_address);", "", "\tkretprobe_hash_unlock(current, &flags);", "", "\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {", "\t\thlist_del(&ri->hlist);", "\t\tkfree(ri);", "\t}"], "file_path": "arch/ia64/kernel/kprobes.c"}
{"Link_to_commit": "https://github.com/djshinnaru/Legado-sentinel/commit/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://github.com/khushikawade/soc_mobile_app/commit/b36705d24f52e9c7a46f9a19078264aff874833f", "n-gram matched": "generated by copilot", "n_lines_longer_change": 12, "n_files_impacted": 1, "longest_chunk": ["/**", " * Automatically generated file. DO NOT MODIFY", " */", "package com.calendar.page.example.example;", "", "public final class BuildConfig {", "  public static final boolean DEBUG = Boolean.parseBoolean(\"true\");", "  public static final String APPLICATION_ID = \"com.calendar.page.example.example\";", "  public static final String BUILD_TYPE = \"debug\";", "  public static final int VERSION_CODE = 1;", "  public static final String VERSION_NAME = \"1.0.0\";", "}"], "file_path": "flutter_calendar_view-master/example/build/app/generated/source/buildConfig/debug/com/calendar/page/example/example/BuildConfig.java"}
{"Link_to_commit": "https://github.com/adekunah/Azure-Sentinel/commit/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://github.com/NothingOSS/android_kernel_msm-6.1_nothing_sm7635/commit/e98653b1be1521039c56a905ccc4860bac47118c", "n-gram matched": "generated by copilot", "n_lines_longer_change": 100, "n_files_impacted": 1, "longest_chunk": ["# Default theme", "html_theme = 'sphinx_rtd_theme'", "html_css_files = []", "", "if \"DOCS_THEME\" in os.environ:", "    html_theme = os.environ[\"DOCS_THEME\"]", "", "if html_theme == 'sphinx_rtd_theme' or html_theme == 'sphinx_rtd_dark_mode':", "    # Read the Docs theme", "    try:", "        import sphinx_rtd_theme", "        html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]", "", "        # Add any paths that contain custom static files (such as style sheets) here,", "        # relative to this directory. They are copied after the builtin static files,", "        # so a file named \"default.css\" will overwrite the builtin \"default.css\".", "        html_css_files = [", "            'theme_overrides.css',", "        ]", "", "        # Read the Docs dark mode override theme", "        if html_theme == 'sphinx_rtd_dark_mode':", "            try:", "                import sphinx_rtd_dark_mode", "                extensions.append('sphinx_rtd_dark_mode')", "            except ImportError:", "                html_theme == 'sphinx_rtd_theme'", "", "        if html_theme == 'sphinx_rtd_theme':", "                # Add color-specific RTD normal mode", "                html_css_files.append('theme_rtd_colors.css')", "", "    except ImportError:", "        html_theme = 'classic'", "", "if \"DOCS_CSS\" in os.environ:", "    css = os.environ[\"DOCS_CSS\"].split(\" \")", "", "    for l in css:", "        html_css_files.append(l)", "", "if major <= 1 and minor < 8:", "    html_context = {", "        'css_files': [],", "    }", "", "    for l in html_css_files:", "        html_context['css_files'].append('_static/' + l)", "", "if  html_theme == 'classic':", "    html_theme_options = {", "        'rightsidebar':        False,", "        'stickysidebar':       True,", "        'collapsiblesidebar':  True,", "        'externalrefs':        False,", "", "        'footerbgcolor':       \"white\",", "        'footertextcolor':     \"white\",", "        'sidebarbgcolor':      \"white\",", "        'sidebarbtncolor':     \"black\",", "        'sidebartextcolor':    \"black\",", "        'sidebarlinkcolor':    \"#686bff\",", "        'relbarbgcolor':       \"#133f52\",", "        'relbartextcolor':     \"white\",", "        'relbarlinkcolor':     \"white\",", "        'bgcolor':             \"white\",", "        'textcolor':           \"black\",", "        'headbgcolor':         \"#f2f2f2\",", "        'headtextcolor':       \"#20435c\",", "        'headlinkcolor':       \"#c60f0f\",", "        'linkcolor':           \"#355f7c\",", "        'visitedlinkcolor':    \"#355f7c\",", "        'codebgcolor':         \"#3f3f3f\",", "        'codetextcolor':       \"white\",", "", "        'bodyfont':            \"serif\",", "        'headfont':            \"sans-serif\",", "    }", "", "sys.stderr.write(\"Using %s theme\\n\" % html_theme)"], "file_path": "Documentation/conf.py"}
{"Link_to_commit": "https://github.com/RdL3gHaKr/Azure-Sentinel/commit/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://github.com/AOSP-Krypton/kernel_xiaomi_lmi/commit/4dd00bfb425b7ba23abddb8bd3356cc36b4d5903", "n-gram matched": "generated by copilot", "n_lines_longer_change": 150, "n_files_impacted": 5, "longest_chunk": ["\tstruct kretprobe_instance *ri = NULL;", "\tstruct hlist_head *head, empty_rp;", "\tstruct hlist_node *tmp;", "\tunsigned long flags, orig_ret_address = 0;", "\tunsigned long trampoline_address =", "\t\t(unsigned long)dereference_function_descriptor(kretprobe_trampoline);", "", "\tINIT_HLIST_HEAD(&empty_rp);", "\tkretprobe_hash_lock(current, &head, &flags);", "", "\t/*", "\t * It is possible to have multiple instances associated with a given", "\t * task either because an multiple functions in the call path", "\t * have a return probe installed on them, and/or more than one return", "\t * return probe was registered for a target function.", "\t *", "\t * We can handle this because:", "\t *     - instances are always inserted at the head of the list", "\t *     - when multiple return probes are registered for the same", "\t *       function, the first instance's ret_addr will point to the", "\t *       real return address, and all the rest will point to", "\t *       kretprobe_trampoline", "\t */", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "", "\tregs->cr_iip = orig_ret_address;", "", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\tif (ri->rp && ri->rp->handler)", "\t\t\tri->rp->handler(ri, regs);", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\trecycle_rp_inst(ri, &empty_rp);", "", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "\tkretprobe_assert(ri, orig_ret_address, trampoline_address);", "", "\tkretprobe_hash_unlock(current, &flags);", "", "\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {", "\t\thlist_del(&ri->hlist);", "\t\tkfree(ri);", "\t}"], "file_path": "arch/ia64/kernel/kprobes.c"}
{"Link_to_commit": "https://github.com/jvicknesh04/Azure-Sentinel/commit/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://github.com/20203tn097/Sentinel-Azure/commit/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
