{"Link_to_commit": "https://api.github.com/repos/0xmicrosoft15/duckdb-rich-sql/commits/ac4ba19da526c4ec2c009b90a25898914b01d71b", "n-gram matched": "generated by copilot", "n_lines_longer_change": 235, "n_files_impacted": 15, "longest_chunk": ["#include \"duckdb/parser/tableref/at_clause.hpp\"", "", "namespace duckdb {", "", "AtClause::AtClause(string unit_p, unique_ptr<ParsedExpression> expr_p)", "    : unit(std::move(unit_p)), expr(std::move(expr_p)) {", "}", "", "string AtClause::ToString() const {", "\treturn \"AT (\" + unit + \" => \" + expr->ToString() + \")\";", "}", "", "bool AtClause::Equals(const AtClause &other) const {", "\treturn unit == other.unit && expr->Equals(*other.expr);", "}", "", "unique_ptr<AtClause> AtClause::Copy() const {", "\treturn make_uniq<AtClause>(unit, expr->Copy());", "}", "", "bool AtClause::Equals(optional_ptr<AtClause> lhs, optional_ptr<AtClause> rhs) {", "\tif (lhs.get() == rhs.get()) {", "\t\t// same pointer OR both are null", "\t\treturn true;", "\t}", "\tif (!lhs || !rhs) {", "\t\t// one is NULL other is not - always not equal", "\t\treturn false;", "\t}", "\treturn lhs->Equals(*rhs);", "}", "", "} // namespace duckdb"], "file_path": "src/parser/tableref/at_clause.cpp"}
{"Link_to_commit": "https://api.github.com/repos/amarantesharlon/duckdb/commits/242d3f78e4651f5f99f77f33cc05d2b72a986d3d", "n-gram matched": "generated by copilot", "n_lines_longer_change": 235, "n_files_impacted": 15, "longest_chunk": ["#include \"duckdb/parser/tableref/at_clause.hpp\"", "", "namespace duckdb {", "", "AtClause::AtClause(string unit_p, unique_ptr<ParsedExpression> expr_p)", "    : unit(std::move(unit_p)), expr(std::move(expr_p)) {", "}", "", "string AtClause::ToString() const {", "\treturn \"AT (\" + unit + \" => \" + expr->ToString() + \")\";", "}", "", "bool AtClause::Equals(const AtClause &other) const {", "\treturn unit == other.unit && expr->Equals(*other.expr);", "}", "", "unique_ptr<AtClause> AtClause::Copy() const {", "\treturn make_uniq<AtClause>(unit, expr->Copy());", "}", "", "bool AtClause::Equals(optional_ptr<AtClause> lhs, optional_ptr<AtClause> rhs) {", "\tif (lhs.get() == rhs.get()) {", "\t\t// same pointer OR both are null", "\t\treturn true;", "\t}", "\tif (!lhs || !rhs) {", "\t\t// one is NULL other is not - always not equal", "\t\treturn false;", "\t}", "\treturn lhs->Equals(*rhs);", "}", "", "} // namespace duckdb"], "file_path": "src/parser/tableref/at_clause.cpp"}
{"Link_to_commit": "https://api.github.com/repos/duckdb/duckdb/commits/242d3f78e4651f5f99f77f33cc05d2b72a986d3d", "n-gram matched": "generated by copilot", "n_lines_longer_change": 235, "n_files_impacted": 15, "longest_chunk": ["#include \"duckdb/parser/tableref/at_clause.hpp\"", "", "namespace duckdb {", "", "AtClause::AtClause(string unit_p, unique_ptr<ParsedExpression> expr_p)", "    : unit(std::move(unit_p)), expr(std::move(expr_p)) {", "}", "", "string AtClause::ToString() const {", "\treturn \"AT (\" + unit + \" => \" + expr->ToString() + \")\";", "}", "", "bool AtClause::Equals(const AtClause &other) const {", "\treturn unit == other.unit && expr->Equals(*other.expr);", "}", "", "unique_ptr<AtClause> AtClause::Copy() const {", "\treturn make_uniq<AtClause>(unit, expr->Copy());", "}", "", "bool AtClause::Equals(optional_ptr<AtClause> lhs, optional_ptr<AtClause> rhs) {", "\tif (lhs.get() == rhs.get()) {", "\t\t// same pointer OR both are null", "\t\treturn true;", "\t}", "\tif (!lhs || !rhs) {", "\t\t// one is NULL other is not - always not equal", "\t\treturn false;", "\t}", "\treturn lhs->Equals(*rhs);", "}", "", "} // namespace duckdb"], "file_path": "src/parser/tableref/at_clause.cpp"}
{"Link_to_commit": "https://api.github.com/repos/xdroid-devices/xd_kernel_xiaomi_lmi/commits/4dd00bfb425b7ba23abddb8bd3356cc36b4d5903", "n-gram matched": "generated by copilot", "n_lines_longer_change": 150, "n_files_impacted": 5, "longest_chunk": ["\tstruct kretprobe_instance *ri = NULL;", "\tstruct hlist_head *head, empty_rp;", "\tstruct hlist_node *tmp;", "\tunsigned long flags, orig_ret_address = 0;", "\tunsigned long trampoline_address =", "\t\t(unsigned long)dereference_function_descriptor(kretprobe_trampoline);", "", "\tINIT_HLIST_HEAD(&empty_rp);", "\tkretprobe_hash_lock(current, &head, &flags);", "", "\t/*", "\t * It is possible to have multiple instances associated with a given", "\t * task either because an multiple functions in the call path", "\t * have a return probe installed on them, and/or more than one return", "\t * return probe was registered for a target function.", "\t *", "\t * We can handle this because:", "\t *     - instances are always inserted at the head of the list", "\t *     - when multiple return probes are registered for the same", "\t *       function, the first instance's ret_addr will point to the", "\t *       real return address, and all the rest will point to", "\t *       kretprobe_trampoline", "\t */", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "", "\tregs->cr_iip = orig_ret_address;", "", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\tif (ri->rp && ri->rp->handler)", "\t\t\tri->rp->handler(ri, regs);", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\trecycle_rp_inst(ri, &empty_rp);", "", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "\tkretprobe_assert(ri, orig_ret_address, trampoline_address);", "", "\tkretprobe_hash_unlock(current, &flags);", "", "\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {", "\t\thlist_del(&ri->hlist);", "\t\tkfree(ri);", "\t}"], "file_path": "arch/ia64/kernel/kprobes.c"}
{"Link_to_commit": "https://api.github.com/repos/adekunah/Azure-Sentinel/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://api.github.com/repos/AOSP-Krypton/kernel_xiaomi_lmi/commits/4dd00bfb425b7ba23abddb8bd3356cc36b4d5903", "n-gram matched": "generated by copilot", "n_lines_longer_change": 150, "n_files_impacted": 5, "longest_chunk": ["\tstruct kretprobe_instance *ri = NULL;", "\tstruct hlist_head *head, empty_rp;", "\tstruct hlist_node *tmp;", "\tunsigned long flags, orig_ret_address = 0;", "\tunsigned long trampoline_address =", "\t\t(unsigned long)dereference_function_descriptor(kretprobe_trampoline);", "", "\tINIT_HLIST_HEAD(&empty_rp);", "\tkretprobe_hash_lock(current, &head, &flags);", "", "\t/*", "\t * It is possible to have multiple instances associated with a given", "\t * task either because an multiple functions in the call path", "\t * have a return probe installed on them, and/or more than one return", "\t * return probe was registered for a target function.", "\t *", "\t * We can handle this because:", "\t *     - instances are always inserted at the head of the list", "\t *     - when multiple return probes are registered for the same", "\t *       function, the first instance's ret_addr will point to the", "\t *       real return address, and all the rest will point to", "\t *       kretprobe_trampoline", "\t */", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "", "\tregs->cr_iip = orig_ret_address;", "", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\tif (ri->rp && ri->rp->handler)", "\t\t\tri->rp->handler(ri, regs);", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\trecycle_rp_inst(ri, &empty_rp);", "", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "\tkretprobe_assert(ri, orig_ret_address, trampoline_address);", "", "\tkretprobe_hash_unlock(current, &flags);", "", "\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {", "\t\thlist_del(&ri->hlist);", "\t\tkfree(ri);", "\t}"], "file_path": "arch/ia64/kernel/kprobes.c"}
{"Link_to_commit": "https://api.github.com/repos/NusantaraROM-Devices/kernel_xiaomi_lmi/commits/4dd00bfb425b7ba23abddb8bd3356cc36b4d5903", "n-gram matched": "generated by copilot", "n_lines_longer_change": 150, "n_files_impacted": 5, "longest_chunk": ["\tstruct kretprobe_instance *ri = NULL;", "\tstruct hlist_head *head, empty_rp;", "\tstruct hlist_node *tmp;", "\tunsigned long flags, orig_ret_address = 0;", "\tunsigned long trampoline_address =", "\t\t(unsigned long)dereference_function_descriptor(kretprobe_trampoline);", "", "\tINIT_HLIST_HEAD(&empty_rp);", "\tkretprobe_hash_lock(current, &head, &flags);", "", "\t/*", "\t * It is possible to have multiple instances associated with a given", "\t * task either because an multiple functions in the call path", "\t * have a return probe installed on them, and/or more than one return", "\t * return probe was registered for a target function.", "\t *", "\t * We can handle this because:", "\t *     - instances are always inserted at the head of the list", "\t *     - when multiple return probes are registered for the same", "\t *       function, the first instance's ret_addr will point to the", "\t *       real return address, and all the rest will point to", "\t *       kretprobe_trampoline", "\t */", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "", "\tregs->cr_iip = orig_ret_address;", "", "\thlist_for_each_entry_safe(ri, tmp, head, hlist) {", "\t\tif (ri->task != current)", "\t\t\t/* another task is sharing our hash bucket */", "\t\t\tcontinue;", "", "\t\tif (ri->rp && ri->rp->handler)", "\t\t\tri->rp->handler(ri, regs);", "", "\t\torig_ret_address = (unsigned long)ri->ret_addr;", "\t\trecycle_rp_inst(ri, &empty_rp);", "", "\t\tif (orig_ret_address != trampoline_address)", "\t\t\t/*", "\t\t\t * This is the real return address. Any other", "\t\t\t * instances associated with this task are for", "\t\t\t * other calls deeper on the call stack", "\t\t\t */", "\t\t\tbreak;", "\t}", "\tkretprobe_assert(ri, orig_ret_address, trampoline_address);", "", "\tkretprobe_hash_unlock(current, &flags);", "", "\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {", "\t\thlist_del(&ri->hlist);", "\t\tkfree(ri);", "\t}"], "file_path": "arch/ia64/kernel/kprobes.c"}
{"Link_to_commit": "https://api.github.com/repos/russellmatt27/Sentinel/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://api.github.com/repos/SivaTejaReddy12125/SentinelLab/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://api.github.com/repos/khushikawade/soc_mobile_app/commits/b36705d24f52e9c7a46f9a19078264aff874833f", "n-gram matched": "generated by copilot", "n_lines_longer_change": 12, "n_files_impacted": 1, "longest_chunk": ["/**", " * Automatically generated file. DO NOT MODIFY", " */", "package com.calendar.page.example.example;", "", "public final class BuildConfig {", "  public static final boolean DEBUG = Boolean.parseBoolean(\"true\");", "  public static final String APPLICATION_ID = \"com.calendar.page.example.example\";", "  public static final String BUILD_TYPE = \"debug\";", "  public static final int VERSION_CODE = 1;", "  public static final String VERSION_NAME = \"1.0.0\";", "}"], "file_path": "flutter_calendar_view-master/example/build/app/generated/source/buildConfig/debug/com/calendar/page/example/example/BuildConfig.java"}
{"Link_to_commit": "https://api.github.com/repos/deepsharan2812/Microsoft-Sentinel/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://api.github.com/repos/Azure/Azure-Sentinel/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://api.github.com/repos/utkarsh2102-debian-elts/qt4-x11/commits/a6f24792a2fb9a00a5a72ab58ffcf98301409ca7", "n-gram matched": "generated by copilot", "n_lines_longer_change": 25, "n_files_impacted": 1, "longest_chunk": ["#include <sys/types.h>", "#include <dirent.h>", "#include <errno.h>", "#include <stdio.h>", "", "main() {", "  int return_code;", "  DIR *dir;", "  struct dirent entry;", "  struct dirent *result;", "", "  if ((dir = opendir(\".\")) == NULL)", "    perror(\"opendir() error\");", "  else {", " //   puts(\"contents of .:\");", "    for (return_code = readdir_r(dir, &entry, &result);", "         result != NULL && return_code == 0;", "         return_code = readdir_r(dir, &entry, &result))", "      printf(\"%s\\n\", entry.d_name);", "    if (return_code != 0)", "      perror(\"readdir_r() error\");", "    closedir(dir);", "  }", "}", ""], "file_path": "debian/readdir-hppa-test.c"}
{"Link_to_commit": "https://api.github.com/repos/EmrulIPB247/Sentinel/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://api.github.com/repos/almost-matching-exactly/DAME-FLAME-Python-Package/commits/879822ff07ff6ec25101e20d44bf79409b5c702e", "n-gram matched": "generated by copilot", "n_lines_longer_change": 171, "n_files_impacted": 4, "longest_chunk": ["", "def var_ATE(matching_object, mice_iter=0):", "    '''", "    This is an EXPERIMENTAL function that implements the variance found in ", "    Abadie, Drukker, Herr, and Imbens (The Stata Journal, 2004) assuming", "    constant treatment effect and homoscedasticity. Note that the implemented ", "    estimator is NOT asymptotically normal and so in particular, ", "    asymptotically valid confidence intervals or hypothesis tests cannot be ", "    conducted on its basis. In the future, the estimation procedure will be ", "    changed.", "", "    Parameters", "    ----------", "    matching_object : TYPE", "        DESCRIPTION.", "    mice_iter : TYPE, optional", "        DESCRIPTION. The default is 0.", "", "    Returns", "    -------", "    variance: float", "    '''", "    validate_matching_obj(matching_object)", "", "    # Compute the sigma^2 estimate from equation 10 in Abadie et al", "    # units_per_group is in format [[#,#,#,...], [#,#,#,...],..]", "    # Need to double check this, if mice_iter != 0, then possibly need to index", "    units_per_group = matching_object.units_per_group", "    ", "    mmgs_dict = all_MGs(matching_object)", "    # print(mmgs_dict)", "        ", "    # Compute K_dict, which maps i to KM value", "    K_dict = dict.fromkeys(mmgs_dict,0)", "    km_temp = 0", "    treated_col = matching_object.treatment_column_name", "    for i in matching_object.df_units_and_covars_matched.index:        ", "        # iterate through all matched units of indexes with opposite treatment", "        # values. How many of those MMGs am I in, and", "        # if I'm in someone's MMG, what is the size of their MMG?", "", "        is_treatment_val = matching_object.input_data.loc[i, treated_col]", "        ", "        ''' # This works for only the without repeats case!", "        for group in units_per_group:", "            if i in group:", "                # find out how many people in this mmg", "                # have the opposite treatment status to the treatment_val_mmg", "                num_treated = sum(matching_object.input_data.loc[group, 'treated'])", "                if is_treatment_val:", "                    num_opposite = len(group) - num_treated", "                else:", "                    num_opposite = num_treated", "                    ", "                K_dict[i] += num_opposite/(len(group)-num_opposite) # is this right???  # (num_opposite/len(group)) # I think this is right per convo w Vittorio", "        ''' # This works for both! Technically somewhat slower though!", "        for j in matching_object.df_units_and_covars_matched.index:", "            if i in mmgs_dict[j] and matching_object.input_data.loc[j, treated_col] != is_treatment_val:", "                num_treated = sum(matching_object.input_data.loc[mmgs_dict[j], treated_col])", "                if matching_object.input_data.loc[j, treated_col]: # double think -- you have to be opposite of j != opp of i", "                    num_opposite = len(mmgs_dict[j]) - num_treated", "                else:", "                    num_opposite = num_treated", "                # print(\"i\", i, \"j\", j, \"num_opp\", num_opposite)", "                K_dict[i] += 1/num_opposite", "        ", "    # print(K_dict)", "    # Compute ATE per simple estimator in paper -- this should be right", "    ate = 0", "    for i in mmgs_dict:", "        treatment_val = matching_object.input_data.loc[i, treated_col]", "        outcome_val = matching_object.input_data.loc[", "            i, matching_object.outcome_column_name]", "        ate += ((2*treatment_val - 1)*(1 + K_dict[i])*outcome_val)", "    ate = ate/len(mmgs_dict)", "        ", "    # Compute sigma^2. ", "    i_summation = 0", "    for i in mmgs_dict:", "        group_members = mmgs_dict[i] # these are the l values in Jm(i)", "        treatment_val = matching_object.input_data.loc[i, treated_col]", "        outcome_val = matching_object.input_data.loc[", "            i, matching_object.outcome_column_name]", "        opp_group_members = matching_object.input_data.loc[group_members].index[matching_object.input_data.loc[group_members][treated_col] != treatment_val].tolist()", "        # iterate through my group members -- only the ones w opp treatment to me!", "        temp_l_summation = 0", "        for l in opp_group_members:", "            Y_l = matching_object.input_data.loc[", "            l, matching_object.outcome_column_name]", "            if treatment_val:", "                temp_l_summation += ((outcome_val - Y_l - ate)**2)", "            else:", "                temp_l_summation += ((Y_l - outcome_val - ate)**2)         ", "        i_summation += temp_l_summation/len(opp_group_members)", "    sigma_squared = 1/(2*len(mmgs_dict))*i_summation", "    ", "    # Combine the above to compute var_estimator", "    dict_summation = 0", "    for key, value in K_dict.items():", "        dict_summation += (1+value)**2", "    var_estimator = sigma_squared*dict_summation/(len(mmgs_dict)**2)", "    ", "    return var_estimator, ate"], "file_path": "dame_flame/utils/post_processing.py"}
{"Link_to_commit": "https://api.github.com/repos/mikebarlow/mikebarlow.github.io/commits/a10243a018d5384dd741c4070a87ec8ef91ce141", "n-gram matched": "generated by copilot", "n_lines_longer_change": 325, "n_files_impacted": 7, "longest_chunk": ["const defaultTheme = require(\"tailwindcss/defaultTheme\");", "", "module.exports = {", "  content: [\"./**/*.html\"],", "  safelist: [\"active\"],", "  theme: {", "    fontFamily: {", "      header: [\"Raleway\", \"sans-serif\"],", "      body: [\"Open Sans\", \"sans-serif\"],", "    },", "", "    screens: {", "      xs: \"375px\",", "      ...defaultTheme.screens,", "    },", "", "    colors: {", "      transparent: \"transparent\",", "      primary: \"#5540af\",", "      secondary: \"#252426\",", "      white: \"#ffffff\",", "      black: \"#000000\",", "      yellow: \"#f9e71c\",", "      lila: \"#e6e5ec\",", "      \"grey-10\": \"#6c6b6d\",", "      \"grey-20\": \"#7c7c7c\",", "      \"grey-30\": \"#919091\",", "      \"grey-40\": \"#929293\",", "      \"grey-50\": \"#f4f3f8\",", "      \"grey-60\": \"#edebf6\",", "      \"grey-70\": \"#d8d8d8\",", "      \"hero-gradient-from\": \"rgba(85, 64, 174, 0.95)\",", "      \"hero-gradient-to\": \"rgba(65, 47, 144, 0.93)\",", "      \"blog-gradient-from\": \"#8f9098\",", "      \"blog-gradient-to\": \"#222222\",", "    },", "", "    container: {", "      center: true,", "      padding: \"1rem\",", "    },", "", "    shadows: {", "      default: \"0 2px 18px rgba(0, 0, 0, 0.06)\",", "      md: \"0 -3px 36px rgba(0, 0, 0, 0.12)\",", "    },", "", "    extend: {", "      spacing: {", "        13: \"3.25rem\",", "        15: \"3.75rem\",", "        17: \"4.25rem\",", "        18: \"4.5rem\",", "        19: \"4.75rem\",", "        42: \"10.5rem\",", "        76: \"19rem\",", "        84: \"21rem\",", "        88: \"22rem\",", "        92: \"23rem\",", "        100: \"25rem\",", "        104: \"26rem\",", "        108: \"27rem\",", "        112: \"28rem\",", "        116: \"29rem\",", "        120: \"30rem\",", "        124: \"31rem\",", "        128: \"32rem\",", "        132: \"33rem\",", "        136: \"34rem\",", "        140: \"35rem\",", "        144: \"36rem\",", "        148: \"37rem\",", "        152: \"38rem\",", "        156: \"39rem\",", "        160: \"40rem\",", "        164: \"41rem\",", "        168: \"42rem\",", "        172: \"43rem\",", "        176: \"44rem\",", "        180: \"45rem\",", "        184: \"46rem\",", "        188: \"47rem\",", "        190: \"48rem\",", "        194: \"49rem\",", "        200: \"50rem\",", "        204: \"51rem\",", "      },", "      zIndex: {", "        \"-1\": \"-1\",", "        60: \"60\",", "        70: \"70\",", "      },", "      inset: {", "        \"2/5\": \"40%\",", "      },", "    },", "  },", "  plugins: [", "    require(\"@tailwindcss/typography\"),", "    require(\"@tailwindcss/forms\"),", "    require(\"@tailwindcss/aspect-ratio\"),", "  ],", "};"], "file_path": "tailwind.config.js"}
{"Link_to_commit": "https://api.github.com/repos/cespinoza01/AzureSentinel/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://api.github.com/repos/djshinnaru/Legado-sentinel/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://api.github.com/repos/RdL3gHaKr/Azure-Sentinel/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
{"Link_to_commit": "https://api.github.com/repos/jvicknesh04/Azure-Sentinel/commits/27f02d17c5516dab768afda28edd82e6ab25d215", "n-gram matched": "generated by copilot", "n_lines_longer_change": 233, "n_files_impacted": 5, "longest_chunk": ["import { runCheckOverChangedFiles } from \"./../utils/changedFilesValidator\";", "import * as logger from \"./../utils/logger\";", "import { ExitCode } from \"./../utils/exitCode\";", "import fs from \"fs\";", "import { MainTemplateValidationError } from \"./../utils/validationError\";", "", "// initialize arrays to store valid domains and verticals", "let validDomains: string[] = [];", "let validVerticals: string[] = [];", "", "// read the valid domains and verticals from the JSON file", "try {", "    const validDomainsVerticals = JSON.parse(fs.readFileSync('./.script/SolutionValidations/ValidDomainsVerticals.json', \"utf8\"));", "    validDomains = validDomainsVerticals.validDomains;", "    validVerticals = validDomainsVerticals.validVerticals;", "} catch (error) {", "    logger.logError(`Error reading ValidDomainsVerticals.json file: ${error}`);", "}", "", "// function to check if the solution is valid", "export async function IsValidSolution(filePath: string): Promise<ExitCode> {", "", "    // check if the file is a mainTemplate.json file", "    if (filePath.endsWith(\"mainTemplate.json\")) {", "        // read the content of the file", "        let jsonFile = JSON.parse(fs.readFileSync(filePath, \"utf8\"));", "", "        // check if the file has a \"resources\" field", "        if (!jsonFile.hasOwnProperty(\"resources\")) {", "            console.warn(`No \"resources\" field found in the file. Skipping file path: ${filePath}`);", "            return ExitCode.SUCCESS;", "        }", "", "        // get the resources from the file", "        let resources = jsonFile.resources;", "", "        // filter resources that have type \"Microsoft.OperationalInsights/workspaces/providers/metadata\"", "        const filteredResource = resources.filter(function (resource: { type: string; }) {", "            return resource.type === \"Microsoft.OperationalInsights/workspaces/providers/metadata\";", "        });", "        if (filteredResource.length > 0) {", "            filteredResource.forEach((element: { hasOwnProperty: (arg0: string) => boolean; properties: { hasOwnProperty: (arg0: string) => boolean; categories: any; }; }) => {", "                // check if the resource has a \"properties\" field", "                if (element.hasOwnProperty(\"properties\") === true) {", "                    // check if the \"properties\" field has a \"categories\" field", "                    if (element.properties.hasOwnProperty(\"categories\") === true) {", "                        const categories = element.properties.categories;", "", "                        let invalidDomains = [];", "                        let invalidVerticals = [];", "", "                        // check if the categories have a \"domains\" field", "                        if (categories.hasOwnProperty(\"domains\")) {", "                            let domains = categories.domains;", "                            if (domains.length === 0) {", "                                throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                            }", "                            for (const domain of domains) {", "                                // check if the domain is valid", "                                if (!validDomains.includes(domain)) {", "                                    invalidDomains.push(domain);", "                                }", "                            }", "                        }", "                        else {", "                            throw new MainTemplateValidationError(\"The solution must include at least one valid domain. Please provide a domain in the 'domains' field of the 'categories' object.\");", "                        }", "", "                        // check if the categories have a \"verticals\" field", "                        if (categories.hasOwnProperty(\"verticals\")) {", "                            let verticals = categories.verticals;", "                            for (const vertical of verticals) {", "                                if (!validVerticals.includes(vertical)) {", "                                    invalidVerticals.push(vertical);", "                                }", "                            }", "                        }", "", "                        if (invalidDomains.length > 0 || invalidVerticals.length > 0) {", "                            let errorMessage = \"Invalid\";", "                            if (invalidDomains.length > 0) {", "                                errorMessage += ` domains: [${invalidDomains.join(\", \")}]`;", "                            }", "                            if (invalidVerticals.length > 0) {", "                                errorMessage += ` verticals: [${invalidVerticals.join(\", \")}]`;", "                            }", "                            errorMessage += ` provided.`;", "                            throw new MainTemplateValidationError(errorMessage);", "                        }", "                    }", "                }", "            });", "        }", "", "        // If the file is not identified as a main template, log a warning message", "    } else {", "        console.warn(`Could not identify json file as a Main Template. Skipping File path: ${filePath}`);", "    }", "", "    // Return success code after completion of the check", "    return ExitCode.SUCCESS;", "}", "", "", "", "", "", "// Array to store file type suffixes for the check", "let fileTypeSuffixes = [\"json\"];", "", "// Array to store file path folder prefixes for the check", "let filePathFolderPrefixes = [\"Solutions\"];", "", "// Array to store file kinds for the check", "let fileKinds = [\"Added\", \"Modified\"];", "", "// Options object to pass to the runCheckOverChangedFiles function", "let CheckOptions = {", "    // Callback function to check if a file is valid", "    onCheckFile: (filePath: string) => {", "        return IsValidSolution(filePath);", "    },", "    // Callback function to handle errors during execution", "    onExecError: async (e: any, filePath: string) => {", "        console.log(`Solution Validation Failed. File path: ${filePath}. Error message: ${e.message}`);", "    },", "    // Callback function to handle final failure", "    onFinalFailed: async () => {", "        logger.logError(\"Please refer link https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/sentinel/sentinel-solutions.md?msclkid=9a240b52b11411ec99ae6736bd089c4a#categories-for-microsoft-sentinel-out-of-the-box-content-and-solutions for valid Domains and Verticals.\");", "    },", "};", "", "// Function call to start the check process", "runCheckOverChangedFiles(CheckOptions, fileKinds, fileTypeSuffixes, filePathFolderPrefixes);"], "file_path": ".script/SolutionValidations/solutionValidator.ts"}
