
LINK NUMBER 1

File path: Game.py
"import pygame
import random

# Initialize PyGame
pygame.init()

# Screen dimensions
WIDTH, HEIGHT = 800, 400
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption(""Jump Over Spikes"")

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)

# Clock for controlling the frame rate
clock = pygame.time.Clock()

# Player settings
player_size = 40
player_x = 100
player_y = HEIGHT - player_size
player_velocity = 0
jump_force = -15
gravity = 1

# Spike settings
spike_width = 20
spike_height = 40
spike_x = WIDTH
spike_y = HEIGHT - spike_height
spike_speed = 10

# Game variables
running = True
is_jumping = False
score = 0
font = pygame.font.Font(None, 36)

# Main loop
while running:
    screen.fill(WHITE)

    # Event handling
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if not is_jumping:
                is_jumping = True
                player_velocity = jump_force

    # Player movement
    if is_jumping:
        player_y += player_velocity
        player_velocity += gravity
        if player_y >= HEIGHT - player_size:
            player_y = HEIGHT - player_size
            is_jumping = False

    # Spike movement
    spike_x -= spike_speed
    if spike_x < -spike_width:
        spike_x = WIDTH
        score += 1

    # Collision detection
    if spike_x < player_x + player_size and spike_x + spike_width > player_x:
        if player_y + player_size >= spike_y:
            running = False  # End the game if the player hits a spike

    # Draw player, spike, and score
    pygame.draw.rect(screen, GREEN, (player_x, player_y, player_size, player_size))
    pygame.draw.polygon(screen, RED, [(spike_x, spike_y), (spike_x + spike_width // 2, spike_y - spike_height), (spike_x + spike_width, spike_y)])
    score_text = font.render(f""Score: {score}"", True, BLACK)
    screen.blit(score_text, (10, 10))

    # Update the display
    pygame.display.flip()
    clock.tick(30)

# Quit PyGame
pygame.quit()"

LINK NUMBER 2
Not enough lines

LINK NUMBER 3
Error fetching diff

LINK NUMBER 4
Error fetching diff

LINK NUMBER 5
Error fetching diff

LINK NUMBER 6
Not enough lines

LINK NUMBER 7

File path: PhotoBank.UnitTests/Enrichers/FaceEnricherTests.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Amazon.Rekognition.Model;
using FluentAssertions;
using ImageMagick;
using Moq;
using NUnit.Framework;
using PhotoBank.DbContext.Models;
using PhotoBank.Dto.Load;
using PhotoBank.Repositories;
using PhotoBank.Services;
using PhotoBank.Services.Enrichers;
using PhotoBank.Services.Enrichers.Services;
using Face = PhotoBank.DbContext.Models.Face;
using Person = PhotoBank.DbContext.Models.Person;

namespace PhotoBank.UnitTests.Enrichers
{
    [TestFixture]
    public class FaceEnricherAwsTests
    {
        private Mock<IFaceServiceAws> _mockFaceService;
        private Mock<IRepository<Person>> _mockPersonRepository;
        private FaceEnricherAws _faceEnricher;
        private List<Person> _persons;

        [SetUp]
        public void Setup()
        {
            _mockFaceService = new Mock<IFaceServiceAws>();
            _mockPersonRepository = new Mock<IRepository<Person>>();
            _persons = new List<Person>
            {
                new Person { Id = 1, Name = ""John Doe"", ExternalGuid = Guid.NewGuid() },
                new Person { Id = 2, Name = ""Jane Doe"", ExternalGuid = Guid.NewGuid() }
            };
            _mockPersonRepository.Setup(repo => repo.GetAll()).Returns(_persons.AsQueryable());
            _faceEnricher = new FaceEnricherAws(_mockFaceService.Object, _mockPersonRepository.Object);
        }

        [Test]
        public void EnricherType_ShouldReturnFace()
        {
            // Act
            var result = _faceEnricher.EnricherType;

            // Assert
            result.Should().Be(EnricherType.Face);
        }

        [Test]
        public void Dependencies_ShouldReturnPreviewAndMetadataEnricher()
        {
            // Act
            var result = _faceEnricher.Dependencies;

            // Assert
            result.Should().Contain(new[] { typeof(PreviewEnricher), typeof(MetadataEnricher) });
        }

        [Test]
        public async Task EnrichAsync_ShouldSetFaceIdentifyStatusToNotDetected_WhenNoFacesDetected()
        {
            // Arrange
            var photo = new Photo();
            var sourceData = new SourceDataDto();
            _mockFaceService.Setup(service => service.DetectFacesAsync(It.IsAny<byte[]>()))
                .ReturnsAsync(new List<FaceDetail>());

            // Act
            await _faceEnricher.EnrichAsync(photo, sourceData);

            // Assert
            photo.FaceIdentifyStatus.Should().Be(FaceIdentifyStatus.NotDetected);
        }

        [Test]
        public async Task EnrichAsync_ShouldSetFaceIdentifyStatusToDetected_WhenFacesDetected()
        {
            // Arrange
            var photo = new Photo();
            var sourceData = new SourceDataDto();
            var detectedFaces = new List<FaceDetail>
            {
                new FaceDetail { BoundingBox = new BoundingBox { Height = 0.1f, Width = 0.1f, Top = 0.1f, Left = 0.1f } }
            };
            _mockFaceService.Setup(service => service.DetectFacesAsync(It.IsAny<byte[]>()))
                .ReturnsAsync(detectedFaces);

            // Act
            await _faceEnricher.EnrichAsync(photo, sourceData);

            // Assert
            photo.FaceIdentifyStatus.Should().Be(FaceIdentifyStatus.Detected);
        }

        [Test]
        public async Task EnrichAsync_ShouldAddFacesToPhoto_WhenFacesDetected()
        {
            // Arrange
            var photo = new Photo();
            var sourceData = new SourceDataDto
            {
                PreviewImage = new MagickImage(new byte[] { 1, 2, 3 })
            };
            var detectedFaces = new List<FaceDetail>
            {
                new FaceDetail { BoundingBox = new BoundingBox { Height = 0.1f, Width = 0.1f, Top = 0.1f, Left = 0.1f } }
            };
            _mockFaceService.Setup(service => service.DetectFacesAsync(It.IsAny<byte[]>()))
                .ReturnsAsync(detectedFaces);

            // Act
            await _faceEnricher.EnrichAsync(photo, sourceData);

            // Assert
            photo.Faces.Should().HaveCount(1);
        }

        [Test]
        public async Task EnrichAsync_ShouldIdentifyFaces_WhenFacesDetected()
        {
            // Arrange
            var photo = new Photo();
            var sourceData = new SourceDataDto
            {
                PreviewImage = new MagickImage(new byte[] { 1, 2, 3 })
            };
            var detectedFaces = new List<FaceDetail>
            {
                new FaceDetail { BoundingBox = new BoundingBox { Height = 0.1f, Width = 0.1f, Top = 0.1f, Left = 0.1f } }
            };
            var userMatches = new List<UserMatch>
            {
                new UserMatch
                {
                    User = new MatchedUser { UserId = _persons[0].Id.ToString() },
                    Similarity = 0.9f
                }
            };
            _mockFaceService.Setup(service => service.DetectFacesAsync(It.IsAny<byte[]>()))
                .ReturnsAsync(detectedFaces);
            _mockFaceService.Setup(service => service.SearchUsersByImageAsync(It.IsAny<byte[]>()))
                .ReturnsAsync(userMatches);

            // Act
            await _faceEnricher.EnrichAsync(photo, sourceData);

            // Assert
            photo.Faces.Should().HaveCount(1);
            photo.Faces[0].IdentityStatus.Should().Be(IdentityStatus.Identified);
            photo.Faces[0].IdentifiedWithConfidence.Should().Be(0.9f);
            photo.Faces[0].Person.Should().Be(_persons[0]);
        }
    }
}
"

LINK NUMBER 8
Not enough lines

LINK NUMBER 9

File path: ticTacToe.py
"def print_board(board):
    for row in board:
        print("" | "".join(row))
        print(""-"" * 9)

def check_winner(board, player):
    # Check rows
    for row in board:
        if all([cell == player for cell in row]):
            return True
    # Check columns
    for col in range(3):
        if all([board[row][col] == player for row in range(3)]):
            return True
    # Check diagonals
    if all([board[i][i] == player for i in range(3)]) or all([board[i][2 - i] == player for i in range(3)]):
        return True
    return False

def tic_tac_toe():
    board = [["" "" for _ in range(3)] for _ in range(3)]
    current_player = ""X""
    for _ in range(9):
        print_board(board)
        try:
            row = int(input(f""Player {current_player}, enter the row (0, 1, 2): ""))
            col = int(input(f""Player {current_player}, enter the column (0, 1, 2): ""))
            if row not in [0, 1, 2] or col not in [0, 1, 2]:
                raise ValueError
            if board[row][col] == "" "":
                board[row][col] = current_player
                if check_winner(board, current_player):
                    print_board(board)
                    print(f""Player {current_player} wins!"")
                    return
                current_player = ""O"" if current_player == ""X"" else ""X""
            else:
                print(""Cell already taken, try again."")
        except ValueError:
            print(""Invalid input, please enter numbers 0, 1, or 2."")
    print_board(board)
    print(""It's a tie!"")

tic_tac_toe()"

LINK NUMBER 10
Error fetching diff

LINK NUMBER 11
Error fetching diff

LINK NUMBER 12
Error fetching diff

LINK NUMBER 13

File path: achievement_tables.py
"def create_table(name, columns, metadata, schema):
    return Table(
        name,
        metadata,
        *columns,
        mysql_engine=MYSQL_ENGINE,
        mysql_charset=MYSQL_CHARSET,
        mysql_collate=MYSQL_COLLATE,
        schema=schema,
    )

achievements_list_columns = ["

LINK NUMBER 14

File path: src/Edi.AspNetCore.Jwt.SqlServer/SqlServerRefreshTokenStore.cs
"        EnsureRefreshTokenTableCreated();

        var tokens = new List<KeyValuePair<string, RefreshToken>>();

        await using var command = _connection.CreateCommand();
        command.CommandText = ""SELECT Id, UserIdentifier, TokenString, ExpireAt FROM RefreshTokens WHERE ExpireAt < @ExpireAt"";
        command.AddParameter(""@ExpireAt"", DbType.DateTime, time);
        await command.ExecuteNonQueryAsync();

        await using var reader = await command.ExecuteReaderAsync();
        while (await reader.ReadAsync())
        {
            tokens.Add(new KeyValuePair<string, RefreshToken>(
                reader.GetString(0),
                new RefreshToken
                {
                    UserIdentifier = reader.GetString(1),
                    TokenString = reader.GetString(2),
                    ExpireAt = reader.GetDateTime(3)
                }));
        }

        return tokens;"

LINK NUMBER 15
Not enough lines

LINK NUMBER 16

File path: DetectDuplicateStringInput/ChkStringDuplicates.cpp
"}

int main()
{
	detectDuplicateWords();
}
"

LINK NUMBER 17
Error fetching diff

LINK NUMBER 18
Error fetching diff

LINK NUMBER 19
Error fetching diff

LINK NUMBER 20

File path: otelcol/internal/stefreceiver/stef.go
"// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package stefreceiver

import (
	""context""
	""testing""

	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
	""go.opentelemetry.io/collector/component/componenttest""
	""go.opentelemetry.io/collector/config/configgrpc""
	""go.opentelemetry.io/collector/config/confignet""
	""go.opentelemetry.io/collector/consumer""
	""go.opentelemetry.io/collector/consumer/consumertest""
	""go.opentelemetry.io/collector/receiver/receivertest""
)

func TestCreateDefaultConfig(t *testing.T) {
	factory := NewFactory()
	cfg := factory.CreateDefaultConfig()
	assert.NotNil(t, cfg, ""failed to create default config"")
	assert.NoError(t, componenttest.CheckConfigStruct(cfg))
}

func TestCreateMetric(t *testing.T) {
	factory := NewFactory()
	defaultGRPCSettings := &configgrpc.ServerConfig{
		NetAddr: confignet.AddrConfig{
			Endpoint:  ""127.0.0.1:0"",
			Transport: confignet.TransportTypeTCP,
		},
	}

	tests := []struct {
		name         string
		cfg          *Config
		wantStartErr bool
		wantErr      bool
		sink         consumer.Metrics
	}{
		{
			name: ""default"",
			cfg: &Config{
				ServerConfig: *defaultGRPCSettings,
			},
			sink: consumertest.NewNop(),
		},
		{
			name: ""invalid_grpc_address"",
			cfg: &Config{
				ServerConfig: configgrpc.ServerConfig{
					NetAddr: confignet.AddrConfig{
						Endpoint:  ""327.0.0.1:1122"",
						Transport: confignet.TransportTypeTCP,
					},
				},
			},
			wantStartErr: true,
			sink:         consumertest.NewNop(),
		},
	}
	ctx := context.Background()
	creationSet := receivertest.NewNopSettings()
	for _, tt := range tests {
		t.Run(
			tt.name, func(t *testing.T) {
				mr, err := factory.CreateMetrics(ctx, creationSet, tt.cfg, tt.sink)
				if tt.wantErr {
					assert.Error(t, err)
					return
				}
				require.NoError(t, err)
				if tt.wantStartErr {
					assert.Error(t, mr.Start(context.Background(), componenttest.NewNopHost()))
				} else {
					require.NoError(t, mr.Start(context.Background(), componenttest.NewNopHost()))
					assert.NoError(t, mr.Shutdown(context.Background()))
				}
			},
		)
	}
}"

LINK NUMBER 21

File path: functional chem quiz code.py
"import random

names = [
    'hydrogen', 'helium', 'lithium', 'beryllium', 'boron', 'carbon', 'nitrogen', 'oxygen', 'fluorine', 'neon', 'sodium', 'magnesium', 'aluminium', 'silicon', 
    'phosphorus', 'sulfur', 'chlorine', 'argon', 'potassium', 'calcium', 'scandium', 'titanium', 'vanadium', 'chromium', 'manganese', 'iron', 'cobalt', 'nickel', 
    'copper', 'zinc', 'gallium', 'germanium', 'arsenic', 'selenium', 'bromine', 'krypton', 'rubidium', 'strontium', 'yttrium', 'zirconium', 'niobium', 
    'molybdenum', 'technetium', 'ruthenium', 'rhodium', 'palladium', 'silver', 'cadmium', 'indium', 'tin', 'antimony', 'tellurium', 'iodine', 'xenon', 
    'cesium', 'barium', 'lanthanum', 'cerium', 'praseodymium', 'neodymium', 'promethium', 'samarium', 'europium', 'gadolinium', 'terbium', 'dysprosium', 
    'holmium', 'erbium', 'thulium', 'ytterbium', 'lutetium', 'hafnium', 'tantalum', 'tungsten', 'rhenium', 'osmium', 'iridium', 'platinum', 'gold', 'mercury', 
    'thallium', 'lead', 'bismuth', 'polonium', 'astatine', 'radon', 'francium', 'radium', 'actinium', 'thorium', 'protactinium', 'uranium', 'neptunium', 
    'plutonium', 'americium', 'curium', 'berkelium', 'californium', 'einsteinium', 'fermium', 'mendelevium', 'nobelium', 'lawrencium', 'rutherfordium', 
    'dubnium', 'seaborgium', 'bohrium', 'hassium', 'meitnerium', 'darmstadtium', 'roentgenium', 'copernicium', 'nihonium', 'flerovium', 'moscovium', 
    'livermorium', 'tennessine', 'oganesson'
]
symbols = [
    'h', 'he', 'li', 'be', 'b', 'c', 'n', 'o', 'f', 'ne', 'na', 'mg', 'al', 'si','p', 's', 'cl', 'ar', 'k', 'ca', 'sc', 'ti', 'v', 'cr', 'mn', 'fe', 'co', 'ni', 
    'cu', 'zn', 'ga', 'ge', 'as', 'se', 'br', 'kr', 'rb', 'sr', 'y', 'zr', 'nb','mo', 'tc', 'ru', 'rh', 'pd', 'ag', 'cd', 'in', 'sn', 'sb', 'te', 'i', 'xe', 
    'cs', 'ba', 'la', 'ce', 'pr', 'nd', 'pm', 'sm', 'eu', 'gd', 'tb', 'dy', 'ho','er', 'tm', 'yb', 'lu', 'hf', 'ta', 'w', 're', 'os', 'ir', 'pt', 'au', 'hg', 
    'tl', 'pb', 'bi', 'po', 'at', 'rn', 'fr', 'ra', 'ac', 'th', 'pa', 'u', 'np','pu', 'am', 'cm', 'bk', 'cf', 'es', 'fm', 'md', 'no', 'lr', 'rf', 'db', 'sg', 
    'bh', 'hs', 'mt', 'ds', 'rg', 'cn', 'nh', 'fl', 'mc', 'lv', 'ts', 'og'
]
ato_num = [
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 
    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 
    83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 
    118
]
groups = [
    1, 18, 1, 2, 13, 14, 15, 16, 17, 18, 1, 2, 13, 14, 15, 16, 17, 18, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1, 2, 3, 4, 5, 6, 
    7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 
    1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18
]
periods = [
    1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
]
try:
    print('This is a chem quiz')
    print('Input range of the quiz, in atomic number (e.g helium-boron is min=2, max=5)')
    min = int(input('Minimum atomic number is: '))
    max = int(input('Maximum atomic number is: '))
    num_questions = int(input('How long should the quiz be: '))
    print('Choose your quiz question (symbol, atomic number, name, group, period, random):')
    print('If chosen symbol, then name is shown and the symbol is the question')
    print('If chosen atomic number, then name is shown and the atomic numbers is the question')
    print('If chosen group, then name is shown and the group is the question')
    print('If chosen period, then name is shown and the period is the question')
    print('If chosen name, then symbol is shown and the name is the question')
    print('If chosen random, each question will have the aforemensioned parts randomised')
    question = str(input('What is your choice:'))
    i=0
    for i in range(0,num_questions):
        ranint = random.randint(min,max)
        ranint = ranint-1 #for list as list begins at zero
        if question.lower() == 'name':
            print(symbols[ranint])
            answer1 = str(input('The name is? '))
            if answer1.lower() == names[ranint]:
                print('Correct!')
            else:
                print('Incorrect')
                print(names[ranint])
        elif question.lower() == 'symbol':
            print(names[ranint])
            answer1 = str(input('The symbols is? '))
            if answer1.lower() == symbols[ranint]:
                print('Correct!')
            else:
                print('Incorrect')
                print(symbols[ranint]) 
        elif question.lower() == 'atomic number':
            print(names[ranint])
            answer1 = int(input('The atomic number is? '))
            if answer1 == ato_num[ranint]:
                print('Correct!')
            else:
                print('Incorrect')
                print(ato_num[ranint]) 
        elif question.lower() == 'group':
            print(names[ranint])
            answer1 = int(input('The group is? '))
            if answer1 == groups[ranint]:
                print('Correct!')
            else:
                print('Incorrect')
                print(groups[ranint]) 
        elif question.lower() == 'period':
            print(names[ranint])
            answer1 = int(input('The period is? '))
            if answer1 == periods[ranint]:
                print('Correct!')
            else:
                print('Incorrect')
                print(periods[ranint])
        elif question.lower() == 'random':
            ranrand = random.randint(1,5) #1 = names, 2=symbols,3=atomic num, 4=groups, 5=periods,
            if ranrand > 1 or ranrand <= 5:
                print(names[ranint])
                if ranrand == 2:
                    answer1 = str(input('The symbols is? '))
                    if answer1.lower() == symbols[ranint]:
                        print('Correct!')
                    else:
                        print('Incorrect')
                        print(symbols[ranint]) 
                elif ranrand == 3:
                    answer1 = int(input('The atomic number is? '))
                    if answer1 == ato_num[ranint]:
                        print('Correct!')
                    else:
                        print('Incorrect')
                        print(ato_num[ranint]) 
                elif ranrand == 4:
                    answer1 = str(input('The group is? '))
                    if answer1 == groups[ranint]:
                        print('Correct!')
                    else:
                        print('Incorrect')
                        print(groups[ranint])
                elif ranrand == 5:
                    answer1 = int(input('The period is? '))
                    if answer1 == periods[ranint]:
                        print('Correct!')
                    else:
                        print('Incorrect')
                        print(periods[ranint])
            elif ranrand == 1:
                print(symbols[ranint])
                answer1 = int(input('The name is? '))
                if answer1.lower() == names[ranint]:
                    print('Correct!')
                else:
                    print('Incorrect')
                    print(names[ranint])

        else:
            print('Incorrect input') 
            break

except ValueError:
    print('There has been a value error')







"

LINK NUMBER 22

File path: suduko.py
"import pygame
import numpy as np
import random

# Define the board size
board_size = 9
# Define the global range of numbers to try for each empty cell
num_range = list(range(1, 10))
# Shuffle the list of numbers to try
random.shuffle(num_range)



# Define the function to print the board
def print_board(board):
    for i in range(board_size):
        for j in range(board_size):
            print(board[i][j], end="" "")
        print()

# Define the function to check if a move is valid
def is_valid_move(board, row, col, num):
    # Check row
    for i in range(board_size):
        if board[row][i] == num:
            return False

    # Check column
    for i in range(board_size):
        if board[i][col] == num:
            return False

    # Check 3x3 box
    box_row = (row // 3) * 3
    box_col = (col // 3) * 3
    for i in range(box_row, box_row + 3):
        for j in range(box_col, box_col + 3):
            if board[i][j] == num:
                return False

    # Move is valid
    return True

# Define the function to solve the board
def solve_board(board):
    # Find the next empty cell
    for i in range(board_size):
        for j in range(board_size):
            if board[i][j] == 0:
                # Try each number from 1 to 9
                for num in num_range:
                    if is_valid_move(board, i, j, num):
                        # Make the move
                        board[i][j] = num

                        # Recursively solve the rest of the board
                        if solve_board(board):
                            return True

                        # Undo the move
                        board[i][j] = 0

                # No valid move found
                return False

    # Board is solved
    return True

# Define the function to generate a random Sudoku puzzle
def generate_puzzle():
    # Start with a solved board
    board = np.zeros((board_size, board_size), dtype=int)
    solve_board(board)

    # Remove some numbers to create the puzzle
    num_removed = 0
    while num_removed < 50:
        row = random.randint(0, board_size - 1)
        col = random.randint(0, board_size - 1)
        if board[row][col] != 0:
            temp = board[row][col]
            board[row][col] = 0
            temp_board = np.copy(board)
            if solve_board(temp_board) and np.count_nonzero(temp_board) == board_size * board_size:
                num_removed += 1
            else:
                board[row][col] = temp

    # Return the puzzle
    return board

# Initialize Pygame
pygame.init()

# Set up the display
screen_width = 540
screen_height = 600
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption(""Sudoku"")

# Set up the font
font = pygame.font.SysFont(None, 40)

# Set up the colors
white = (255, 255, 255)
black = (0, 0, 0)
gray = (128, 128, 128)
light_gray = (192, 192, 192)
red = (255, 0, 0)

# Set up the game variables
selected_row = -1
selected_col = -1
game_over = False
solving = False
new_game = False
board = generate_puzzle()
board_copy = board.copy()

# Set up the game loop
while not game_over:
    # Handle events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            game_over = True
        elif event.type == pygame.MOUSEBUTTONDOWN:
            # Get the mouse position
            pos = pygame.mouse.get_pos()

            # Check if the mouse is on the board
            if pos[0] >= 20 and pos[0] < 500 and pos[1] >= 20 and pos[1] < 500:
                # Get the row and column of the clicked cell
                selected_row = (pos[1] - 20) // 50
                selected_col = (pos[0] - 20) // 50
            else:
                selected_row = -1
                selected_col = -1

            # Check if the mouse is on the solve button
            if pos[0] >= 20 and pos[0] < 140 and pos[1] >= 540 and pos[1] < 580:
                solve_board(board)
                solving = True

            # Check if the mouse is on the new game button
            if pos[0] >= 160 and pos[0] < 340 and pos[1] >= 540 and pos[1] < 580:
                random.shuffle(num_range)
                board = generate_puzzle()
                board_copy = board.copy()
                solving = False

            # Check if the mouse is on the quit button
            if pos[0] >= 380 and pos[0] < 500 and pos[1] >= 540 and pos[1] < 580:
                game_over = True

    # Clear the screen
    screen.fill(white)

    # Draw the board
    for i in range(board_size):
        for j in range(board_size):
            # Draw the cell
            cell_rect = pygame.Rect(j * 50 + 20, i * 50 + 20, 50, 50)
            pygame.draw.rect(screen, black, cell_rect, 1)

            # Draw the number
            if board[i][j] != 0:
                if solving and board[i][j] != board_copy[i][j]:  # Check if solving and not an original number
                    number_color = (0, 128, 0)  # Set solved numbers to green
                else:
                    number_color = black
                number_text = font.render(str(board[i][j]), True, number_color)
                number_rect = number_text.get_rect(center=cell_rect.center)
                screen.blit(number_text, number_rect)
            # Draw the selection
            if i == selected_row and j == selected_col:
                pygame.draw.rect(screen, red, cell_rect, 3)

    # Draw the solve button
    solve_button_rect = pygame.Rect(20, 540, 120, 40)
    pygame.draw.rect(screen, gray, solve_button_rect)
    solve_button_text = font.render(""Solve"", True, black)
    solve_button_text_rect = solve_button_text.get_rect(center=solve_button_rect.center)
    screen.blit(solve_button_text, solve_button_text_rect)

    # Draw the new game button
    new_game_button_rect = pygame.Rect(160, 540, 180, 40)  # Make the button wider
    pygame.draw.rect(screen, gray, new_game_button_rect)
    new_game_button_text = font.render(""New Game"", True, black)
    new_game_button_text_rect = new_game_button_text.get_rect(center=new_game_button_rect.center)
    screen.blit(new_game_button_text, new_game_button_text_rect)

    # Draw the quit button
    quit_button_rect = pygame.Rect(380, 540, 120, 40)
    pygame.draw.rect(screen, gray, quit_button_rect)
    quit_button_text = font.render(""Quit"", True, black)
    quit_button_text_rect = quit_button_text.get_rect(center=quit_button_rect.center)
    screen.blit(quit_button_text, quit_button_text_rect)

    # Update the display
    pygame.display.update()

# Quit Pygame
pygame.quit()"

LINK NUMBER 23

File path: src/Edi.CacheAside.InMemory.Tests/MemoryCacheAsideTests.cs
"using Microsoft.Extensions.Caching.Memory;
using Moq;

namespace Edi.CacheAside.InMemory.Tests
{
    [TestFixture]
    public class MemoryCacheAsideTests
    {
        [Test]
        public void GetOrCreate_NullKey_ReturnsDefault()
        {
            // Arrange
            var mockCache = new Mock<IMemoryCache>();
            var cacheAside = new MemoryCacheAside(mockCache.Object);

            // Act
            var result = cacheAside.GetOrCreate<string>(""testPartition"", null, (_) => ""testValue"");

            // Assert
            Assert.IsNull(result);
        }

        [Test]
        public async Task GetOrCreateAsync_NullKey_ReturnsDefault()
        {
            // Arrange
            var mockCache = new Mock<IMemoryCache>();
            var cacheAside = new MemoryCacheAside(mockCache.Object);

            // Act
            var result = await cacheAside.GetOrCreateAsync<string>(""testPartition"", null, (_) => Task.FromResult(""testValue""));

            // Assert
            Assert.IsNull(result);
        }

        //[Test]
        //public void GetOrCreate_PartitionAndKey_AddsToCachePartition()
        //{
        //    // Arrange
        //    var mockCacheEntry = new Mock<ICacheEntry>();
        //    var mockCache = new Mock<IMemoryCache>();
        //    mockCache.Setup(m => m.GetOrCreate(
        //            It.IsAny<object>(),
        //            It.IsAny<Func<ICacheEntry, string>>()))
        //        .Returns(""testValue"")
        //        .Callback<object, Func<ICacheEntry, string>>((_, factory) => factory(mockCacheEntry.Object));
        //    var cacheAside = new MemoryCacheAside(mockCache.Object);

        //    // Act
        //    var result = cacheAside.GetOrCreate<string>(""testPartition"", ""testKey"", (_) => ""testValue"");

        //    // Assert
        //    Assert.AreEqual(""testValue"", result);
        //    Assert.IsTrue(cacheAside.CachePartitions.ContainsKey(""testPartition""));
        //    Assert.IsTrue(cacheAside.CachePartitions[""testPartition""].Contains(""testKey""));
        //}

        //[Test]
        //public async Task GetOrCreateAsync_PartitionAndKey_AddsToCachePartition()
        //{
        //    // Arrange
        //    var mockCacheEntry = new Mock<ICacheEntry>();
        //    var mockCache = new Mock<IMemoryCache>();
        //    mockCache.Setup(m => m.GetOrCreateAsync(
        //            It.IsAny<object>(),
        //            It.IsAny<Func<ICacheEntry, Task<string>>>()))
        //        .ReturnsAsync(""testValue"")
        //        .Callback<object, Func<ICacheEntry, Task<string>>>((_, factory) => factory(mockCacheEntry.Object));
        //    var cacheAside = new MemoryCacheAside(mockCache.Object);

        //    // Act
        //    var result = await cacheAside.GetOrCreateAsync<string>(""testPartition"", ""testKey"", (_) => Task.FromResult(""testValue""));

        //    // Assert
        //    Assert.AreEqual(""testValue"", result);
        //    Assert.IsTrue(cacheAside.CachePartitions.ContainsKey(""testPartition""));
        //    Assert.IsTrue(cacheAside.CachePartitions[""testPartition""].Contains(""testKey""));
        //}

        [Test]
        public void Clear_CachesExist_RemovesAllFromCache()
        {
            // Arrange
            var mockCache = new Mock<IMemoryCache>();
            var cacheAside = new MemoryCacheAside(mockCache.Object);
            cacheAside.CachePartitions[""testPartition1""] = new[] { ""testKey1"", ""testKey2"" }.ToList();
            cacheAside.CachePartitions[""testPartition2""] = new[] { ""testKey3"" }.ToList();

            mockCache.Setup(m => m.Remove(It.IsAny<object>()))
                .Callback<object>((_) => { });

            mockCache.Setup(m => m.Remove(It.Is<object>(key => key.ToString() == ""testPartition1-testKey1"")))
                .Callback<object>((_) => { });

            mockCache.Setup(m => m.Remove(It.Is<object>(key => key.ToString() == ""testPartition1-testKey2"")))
                .Callback<object>((_) => { });

            mockCache.Setup(m => m.Remove(It.Is<object>(key => key.ToString() == ""testPartition2-testKey3"")))
                .Callback<object>((_) => { });

            // Act            
            cacheAside.Clear();

            // Assert
            mockCache.Verify(m => m.Remove(It.Is<object>(key => key.ToString() == ""testPartition1-testKey1"")), Times.Once);
            mockCache.Verify(m => m.Remove(It.Is<object>(key => key.ToString() == ""testPartition1-testKey2"")), Times.Once);
            mockCache.Verify(m => m.Remove(It.Is<object>(key => key.ToString() == ""testPartition2-testKey3"")), Times.Once);
            mockCache.Verify(m => m.Remove(It.IsAny<object>()), Times.Exactly(3));
        }

        [Test]
        public void Remove_PartitionNotExist_NothingHappens()
        {
            // Arrange
            var mockCache = new Mock<IMemoryCache>();
            var cacheAside = new MemoryCacheAside(mockCache.Object);

            // Act            
            Assert.DoesNotThrow(() => cacheAside.Remove(""testPartitionNotExist""));
        }

        [Test]
        public void Remove_CacheKeysExist_RemovesAllFromCache()
        {
            // Arrange
            var mockCache = new Mock<IMemoryCache>();
            var cacheAside = new MemoryCacheAside(mockCache.Object);
            cacheAside.CachePartitions[""testPartition1""] = new[] { ""testKey1"", ""testKey2"" }.ToList();

            mockCache.Setup(m => m.Remove(""testPartition1-testKey1""));
            mockCache.Setup(m => m.Remove(""testPartition1-testKey2""));

            // Act            
            cacheAside.Remove(""testPartition1"");

            // Assert
            mockCache.Verify(m => m.Remove(""testPartition1-testKey1""), Times.Once);
            mockCache.Verify(m => m.Remove(""testPartition1-testKey2""), Times.Once);
        }

        [Test]
        public void Remove_KeyNotExist_NothingHappens()
        {
            // Arrange
            var mockCache = new Mock<IMemoryCache>();
            var cacheAside = new MemoryCacheAside(mockCache.Object);

            // Act            
            Assert.DoesNotThrow(() => cacheAside.Remove(""testPartition"", ""testKeyNotExist""));
        }

        [Test]
        public void Remove_KeyExist_RemovesFromCache()
        {
            // Arrange
            var mockCache = new Mock<IMemoryCache>();
            var cacheAside = new MemoryCacheAside(mockCache.Object);
            cacheAside.CachePartitions[""testPartition""] = new[] { ""testKey"", ""testKey2"" }.ToList();

            mockCache.Setup(m => m.Remove(""testPartition-testKey""));

            // Act            
            cacheAside.Remove(""testPartition"", ""testKey"");

            // Assert
            mockCache.Verify(m => m.Remove(""testPartition-testKey""), Times.Once);
        }
    }
}"

LINK NUMBER 24
Error fetching diff

LINK NUMBER 25
Error fetching diff

LINK NUMBER 26
Error fetching diff

LINK NUMBER 27
Not enough lines

LINK NUMBER 28

File path: Semester_1/Labs/Lab17/lab_17.py
"from typing import Any, LiteralString


class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        self.children = [self.left, self.right]




class BST:
    def __init__(self):
        self.root = None


    def __insert(self, current, value) -> None:
        if value < current.value:
            if not current.left:
                current.left = Node(value)
            else:
                self.__insert(current.left, value)
        elif value > current.value:
            if not current.right:
                current.right = Node(value)
            else:
                self.__insert(current.right, value)
        else:
            raise Exception(f""{value} already exist!!"")

    def insert(self, value) -> None:
        if not self.root:
            self.root = Node(value)
        else:
            self.__insert(self.root, value)


    def __search(self, value, parent, current) -> tuple | tuple[None, None] | Any | None:
        if value == current.value:
            return (parent, current)
        elif value < current.value:
            if not current.left:
                return (None, None)
            return self.__search(value, current, current.left)
        elif value > current.value:
            if not current.right:
                return (None, None)
            return self.__search(value, current, current.right)
        

    def search(self, value) -> tuple[None, None] | tuple | Any | None:
        if not self.root:
            return (None, None)
        return self.__search(value, parent=self.root, current=self.root)

    def __minValueNode(self, node) -> Any:
        current = node
        while current.left:
            current = current.left
        return current
    
        
    def __remove(self, root, value) -> Any | None:
        if not root:
            return None

        if value < root.value:
            root.left = self.__remove(root.left, value)
        elif value > root.value:
            root.right = self.__remove(root.right, value)
        else:
            if not root.left:
                temp = root.right
                root = None
                return temp

            elif not root.right:
                temp = root.left
                root = None
                return temp
            
            successor = self.__minValueNode(root.right)
            root.value = successor.value
            root.right = self.__remove(root.right, successor.value)
        return root

    def remove(self, value) -> None:
        was_removed = self.__remove(self.root, value)


    def __traversePostOrder(self, current) -> None:
        print(current.value, end=' -- ')
        if current.left:
            self.__traversePostOrder(current.left)
        if current.right:
            self.__traversePostOrder(current.right)

    def traversePostOrder(self) -> None:
        self.__traversePostOrder(self.root)

    
    def __traverseInOrder(self, current) -> None:
        if current.left:
            self.__traverseInOrder(current.left)
        print(current.value, end=' -- ')
        if current.right:
            self.__traverseInOrder(current.right)

    def traverseInOrder(self) -> None:
        self.__traverseInOrder(self.root)


    def __traversePreOrder(self, current) -> None:
        if current.left:
            self.__traversePreOrder(current.left)
        if current.right:
            self.__traversePreOrder(current.right)
        print(current.value, end=' -- ')


    def traversePreOrder(self) -> None:
        self.__traversePreOrder(self.root) 

        
    def traverseNonRecursive(self) -> None:
        from queue import LifoQueue
        stack = LifoQueue()
        stack.put(self.root)
        while not stack.empty():
            current = stack.get()
            while current:
                print(current.value, end=' -- ')
                if current.left:
                    stack.put(current.left)
                current = current.right


    def draw(self) -> None:
        self.root.display()


    def inputBracketNotation(self, string: str) -> None:
        def find_right_subtree(string: str, start: int, end: int):
            bracket_counter = -1
            while True:
                if (start >= end): return -1
                if ((string[start] == ',') and (bracket_counter == 0)): return start + 1
                if string[start] == '(': bracket_counter += 1
                if string[start] == ')': bracket_counter -= 1
                start += 1

        def create_subtree(string: str, start: int, end: int) -> Node:
            while string[start] == ' ' or string[start] == '(': start += 1
            if (start >= end): return

            number = ''
            while string[start] in '1234567890':
                number += string[start]
                start += 1
                if start >= end: return Node(int(number))
            node = Node(int(number))

            right_subtree_index = find_right_subtree(string, start, end) - 1

            if right_subtree_index == -1:
                raise Exception(""Wrong bracket notation string!"")

            if right_subtree_index :
                node.left = create_subtree(string, start+1, right_subtree_index)
                node.right = create_subtree(string, right_subtree_index+1, end - 1)
            return node

        self.root = create_subtree(string, 0, len(string))




if __name__ == ""__main__"":
    bst = BST()
    while True:
        print(''' Enter the number of command you want to execute:
    1) insert the vertexes by values
    2) search the vertexes by values
    3) remove the vertexes by values
    4) traverse Pre-Order
    5) traverse In-Order
    6) traverse Post-Order
    7) traverse Non-Recursive
    8) Enter tree through bracket notation (changes the root element and doesn't assert, that the string is going to be BST)
    0) Exit''')
        command = input()
        match command:
            case '1':
                values = list(map(int, input('Please, enter the values you want to inswrt: ').strip().replace(',', ' ').split()))
                for value in values:
                    bst.insert(value)
            case '2':
                values = list(map(int, input('Please, enter the values of the vertex you are searching: ').strip().replace(',', ' ').split()))
                for value in values:
                    parent, current = bst.search(value); 
                    print(f'Parent value is {parent.value}, searched value is {current.value}')
            case '3':
                values = list(map(int, input('Please, enter the value of the vertex you are searching: ').strip().replace(',', ' ').split()))
                for value in values:
                    bst.remove(value)
            case '4':
                bst.traversePreOrder()
                print()
            case '5':
                bst.traverseInOrder()
                print()
            case '6':
                bst.traversePostOrder()
                print()
            case '7':
                bst.traverseNonRecursive()
                print()
            case '8':
                bst.inputBracketNotation(input('Please, enter the bracket notation string: '))
            case '0':
                break
            case _:
                continue
    bst.traverseInOrder()
    
        "

LINK NUMBER 29

File path: programs/encryption/ai/ai-01.py
"def get_number(uppercase_letter):
    # Define the mapping of letters to digits
    char_numbers = [
        ('ABC', 2), ('DEF', 3), ('GHI', 4), ('JKL', 5),
        ('MNO', 6), ('PQRS', 7), ('TUV', 8), ('WXYZ', 9)
    ]
    
    # Convert uppercase letter to its corresponding digit
    for chars, digit in char_numbers:
        if uppercase_letter in chars:
            return digit
    
    # If the letter is not in the mapping, return the original letter
    return uppercase_letter

def translate_number():
    phone_number = input(""Enter a string: "")
    translated_number = """"

    for char in phone_number.upper():
        if char.isalpha():
            translated_number += str(get_number(char))
        else:
            translated_number += char

    print(""Translated number:"", translated_number)

# Call the function to translate the user input
translate_number()"

LINK NUMBER 30
Not enough lines

LINK NUMBER 31
Error fetching diff

LINK NUMBER 32
Error fetching diff

LINK NUMBER 33
Error fetching diff

LINK NUMBER 34

File path: easy/364/go/main.go
"func roll(dice string) int {
	matches := dicePattern.FindStringSubmatch(dice)
	if len(matches) != 3 {
		return 0
	}
	count, _ := strconv.Atoi(matches[1])
	sides, _ := strconv.Atoi(matches[2])
	sum := 0
	for i := 0; i < count; i++ {
		sum += 1 + rand.Intn(sides)
	}
	return sum"

LINK NUMBER 35
Not enough lines

LINK NUMBER 36

File path: git_log_to_sqlite.py
"#!/usr/bin/env python

import git
import sqlite3
import os
import sys
import datetime

# check if the directory is a git repo
if not os.path.isdir('.git'):
    print('Not a git repo')
    sys.exit(1)

# connect to the database
conn = sqlite3.connect('git_log.db')
c = conn.cursor()

# create the table
c.execute('''CREATE TABLE IF NOT EXISTS commits
                 (id INTEGER PRIMARY KEY,
                 date TEXT,
                 author TEXT,
                 message TEXT)''')

# get the log of commits
repo = git.Repo('./')
for commit in repo.iter_commits():
    # get the date of the commit
    date = datetime.datetime.fromtimestamp(commit.committed_date).strftime('%Y-%m-%d %H:%M:%S')
    # get the author of the commit
    author = commit.author.name
    # get the message of the commit
    message = commit.message
    # insert the commit into the table
    c.execute(""INSERT INTO commits VALUES (NULL, ?, ?, ?)"", (date, author, message))

# commit the changes
conn.commit()

# close the connection
conn.close()"

LINK NUMBER 37

File path: tests/Graph/Graph_Test.cpp
"#include <iostream>
#include ""../../general/Graph.hpp""

void testVertex() {
    // Test default constructor
    Vertex v1;
    assert(v1.x == -1 && v1.y == -1 && v1.color == """");

    // Test constructor with two arguments
    Vertex v2(1, 2);
    assert(v2.x == 1 && v2.y == 2 && v2.color == """");

    // Test constructor with three arguments
    Vertex v3(3, 4, ""red"");
    assert(v3.x == 3 && v3.y == 4 && v3.color == ""red"");

    // Test up() method
    Vertex v4 = v2.up();
    assert(v4.x == 1 && v4.y == 3 && v4.color == """");

    // Test down() method
    Vertex v5 = v2.down();
    assert(v5.x == 1 && v5.y == 1 && v5.color == """");

    // Test left() method
    Vertex v6 = v2.left();
    assert(v6.x == 0 && v6.y == 2 && v6.color == """");

    // Test right() method
    Vertex v7 = v2.right();
    assert(v7.x == 2 && v7.y == 2 && v7.color == """");

    // Test distance() method
    unsigned int d1 = v2.distance(v3);
    assert(d1 == 4);

    unsigned int d2 = v3.distance(v2);
    assert(d2 == 4);

    // Test operator== method
    assert(v2 == v2);
    assert(!(v2 == v3));
}

void testGraph() {
    // Test constructor with no arguments
    Graph g1;
    assert(g1.size() == 0);

    // Test constructor with one argument
    Graph g2(5);
    assert(g2.size() == 5);

    // Test constructor with vector argument (vector of vertices)
    std::vector<Vertex> vertices;
    vertices.push_back(Vertex(1, 2));
    vertices.push_back(Vertex(3, 4));
    Graph g3(vertices);
    assert(g3.size() == 2);

    // Test constructor with unordered_map argument (map of max_edges)
    std::unordered_map<Vertex, int> max_edges;
    max_edges[Vertex(1, 2)] = 3;
    max_edges[Vertex(3, 4)] = 5;
    Graph g4(max_edges);
    assert(g4.size() == 2);

    // Test constructor with unordered_map argument (map of edges)
    std::unordered_map<Vertex, std::vector<Edge> > adj;
    adj[Vertex(1, 2)] = std::vector<Edge>();
    adj[Vertex(3, 4)] = std::vector<Edge>();
    Graph g5(adj);
    assert(g5.size() == 2);

    // Test addVertex() method
    g1.addVertex(Vertex(1, 2));
    assert(g1.size() == 1);

    // Test addDirEdge() and getEdges() methods
    g1.addDirEdge(Edge(Vertex(1, 2), Vertex(3, 4)));
    assert(g1.getEdges(Vertex(1, 2)).size() == 1);

    // Test addUndirEdge() method
    g1.addUndirEdge(Edge(Vertex(1, 2), Vertex(5, 6)));
    assert(g1.getEdges(Vertex(1, 2)).size() == 2);
    assert(g1.getEdges(Vertex(5, 6)).size() == 1);

    // Test setAsVisited() and getVisitedStatus() methods
    g1.setAsVisited(Vertex(1, 2));
    assert(g1.getVisitedStatus(Vertex(1, 2)) == true);

    // Test setMaxEdges() and getMaxEdges() method
    g1.setMaxEdges(Vertex(1, 2), 3);
    assert(g1.getMaxEdges(Vertex(1, 2)) == 3);
}

int main() {
    testVertex();
    testGraph();
    std::cout << ""Tests passed"" << std::endl;
    return 0;
}"
